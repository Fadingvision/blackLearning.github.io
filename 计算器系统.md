# 理解计算器系统和Nodejs

## 进程和线程（process和thread）

![E4krCD.png](https://s2.ax1x.com/2019/05/12/E4krCD.png)

进程是操作系统对运行程序的一种抽象。进程可以让我们假设我门的程序运行在独立的逻辑控制流和私有的地址空间中，尽管我们认为一个进程只有一个单一的控制流，但是在现代系统中，一个进程可以由多个叫做线程的执行单元组成，每个线程都运行在同样的代码环境和上下文中，共享全局的代码和数据。

每个进程都有一个非零的pid.

父进程可以通过fork来创建子进程，新创建的子进程与父进程有着不同的pid, 父进程和子进程一般来说是相互独立的地址空间内并行运行，他们之间可以共享文件。

普通的unix命令执行就相当于创建了一个进程。每个进程执行完毕之后会有返回码，可以通过`echo $?`来查看进程的退出码。

在node中，node程序运行的进程通常被称为主进程，通常会使用`child_process.fork`以及`child_process.exec`来创建新的子进程，其中fork一般可以提供父子进程通信的IPC通道。exec一般用于执行其他的命令程序。

### 进程信号

常用的进程信号：

其中每种类型的信号都对应不同的系统事件，例如键入一个ctrl+c，那么内核就会发送一个`SIGINT`信号给前台进程。一个进程亦可以发送`SIGKILL`信号来强制终止另外一个进程。

![VBUZDK.png](https://s2.ax1x.com/2019/06/08/VBUZDK.png)

一般来说可以用kill来对进程发送进程信号, kill默认是用来杀死进程，但是也可以用来发送其他的信号。

```shell
kill .9 14245(pid)
```

### 进程工具

- __strace__: 用来打印一个程序和它的子进程调用的轨迹。
- __ps__: 列出系统中当前所有的进程，包括僵尸进程。
- __top__: 列出当前进程资源使用的信息。
- __kill__: 发送一个信号给进程。

### I/O

输入/输出是从主程序和外部设备拷贝数据的过程。


### 并发编程

现代操作系统提供了三种用于构造并发程序的方法:

1. 进程

每个逻辑流程都是一个进程，由内核来进行调度和维护。

构造并发程序的最简单的方法就是使用进程。例如我们熟悉的`fork`,`exec`函数，构造一个并发的网络服务器的自然方法就是：在父进程中接收客户端连接的请求，然后创建一个新的子进程来为客户端提供服务，例如`cluster.fork()`方法。

基于这种方式的并发往往需要使用显式的IPC机制。基于进程的设计的往往比较慢，因为进程控制和IPC的开销很高。

> IPC(inner process comunication): 进程间通信，例如socket套接字就是IPC的一种形式，它允许不同主机上的进程交换任意的字节流，但IPC通常指的是同一台主机上的不同进程之间的通信技术。

2. I/O多路复用

这种形式中，进程在一个进程的上下文中显式的调用他们自己的逻辑流。

3. 线程（thread）

线程可以看成上边两种形式的结合体，是运行在一个单独的进程上下文的逻辑流，由内核负责调度。

线程的上下文要比一个进程的上下文小的多，这意味着在进程之间切换并不需要多大的开销。

mutex互斥体: 表示一个可以控制同时间只有一个进程可以读写某个资源。

```go
go func() {
  mu.Lock()
  a = 2
  time.Sleep(time.Millisecond * 500)
  mu.Unlock()
  wa.Done()
}()

go func() {
  mu.Lock()
  a = 3
  time.Sleep(time.Millisecond * 500)
  mu.Unlock()
  wa.Done()
}()
```

Semaphore(信号量): 允许一定数量的进程可以读写某个资源，当资源用尽的时候，则无法继续分配给新的进程使用。 

死锁：信号量引入了一种潜在的令人厌恶的运行时错误，叫做死锁，他指的是一组线程被阻塞了，等待一个永远也不会为真的条件。


## 文件系统

在实例中，每个进程都有一个工作目录，进程可以通过系统调用指定新的工作目录，从而变更其工作目录。在Node中，可以使用`process.pwd()`查看当前进程的工作目录，用`process.chdir(directory)`来改变工作目录。

所有文件的相对目录都是相对于当前的工作目录而言。

在`POSIX`兼容的操作系统中，对于每个进程，内核都会维护一个该进程打开的文件和资源的表，每个打开的文件都会被分配到一个简单数字标识的`文件描述符`。
所有的文件操作都会使用这些文件描述符来认证和追踪对应的文件。

文件保护：对每个文件赋予一个9位的二进制保护代码，对UNIX中的文件实现保护。该保护代码中有三个3位字段，一个用于所有者，一个用于所有者同组中的其他成员，而另一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是知名的`rwx`位。


### 文件类型：

- block divice: 引用指向一个物理设备的文件。

### 硬链接(hard link)和符号链接(symbolic link):

硬链接可以当做源文件的副本，他和源文件一样的带下但是却不占任何空间。

硬链接不允许给目录创建硬链接，并且只允许同一文件系统中的文件之间才能创建链接。

符号链接可以理解为类似windows中的快捷方式，只是一个链接到源文件的引用文件。

符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，也可以链接不同文件系统的文件。在对符号链接进行读写操作的时候，系统会自动把操作转换为对源文件的操作。但是删除链接文件的时候，系统仅仅删除链接文件本身。

### 一些主要与文件相关的系统调用：

1. create: 创建文件，并设置文件的属性。

2. delete: 删除文件，释放磁盘空间。

3. open: 在使用文件之前，必须打开文件，将文件属性和磁盘的地址表装入内存中，便于后续的快速存取。

fs.open会用来为文件分配一个文件描述符，这个描述符可以用来读取文件，写入文件，以及读取文件相关的属性。

```js
fs.open('/open/some/file.txt', 'r', (err, fd) => {
  if (err) throw err;
  // do something with the file discriptor
});
```

4. close: 存取结束后，这时一个关闭文件以释放内存空间，很多系统限制一个进程同时打开的文件个数，就是为了鼓励用户关闭不再使用的文件。

5. read: 再文件中读取数据，一般来说，数据来自文件的当前位置。调用者必须指明需要读取的数据大小，并且提供存放这些数据的缓存区。

`fs.read(fd, buffer, offset, length, position, callback)`

buffer指定了存放该数据的缓存区，
offset指定了buffer的写入位置。
length指定了以字节为单位的想要读取的数据的大小。
position指定了读取数据的位置。
callback接收bytesRead, buffer两个参数。

6. write: 向文件写数据，写操作一般也是从文件当前位置开始。如果当前位置是文件末尾，相当于文件的长度增加，如果当前位置是在文件中间，则现有数据将被覆盖，并且永远丢失。

7. append: 为write的扩展形式，表示只能在文件末尾添加数据。

`fs.append(path | fd, string | buffer, encoding, callback)`

append会为我们自动打开和关闭文件，如果传入的是fd, 则需要自行处理文件关闭。

8. seek: 随机存取文件。

9. get attributes: 读取文件属性。

fs.realpath 读取文件(包括`.`,`..`以及符号链接文件)的真实地址

fs.access测试文件是否存在，以及当前用户读写/执行权限

fs.stats读取文件属性：

```js
Stats {
  dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atimeMs: 1318289051000.1,
  mtimeMs: 1318289051000.1,
  ctimeMs: 1318289051000.1,
  birthtimeMs: 1318289051000.1,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT
}
```

10. set attributes: 设置或者修改文件属性。

11. rename: 改变文件名字。

`fs.rename(oldPath, newPath)`

目录操作：

1. create

2. delete: 删除目录。通常只有空目录可以删除，也就是只包含`.`和`..`的目录。

`fs.rmdir(path, callback)`

3. opendir: 打开目录。

4. closedir: 关闭目录。

5. readdir: 读取目录内容，例如列出目录中全部文件。

6. link: 连接技术允许在多个目录中出现同一个文件。

`fs.symlink(target, path[, type], callback)`

创建一个符号链接名为path指向target.

7. unlink: 删除目录项。如果被结束的文件只出现在一个目录中，则将他从文件系统中删除。

`fs.unlink(path, callback)`
