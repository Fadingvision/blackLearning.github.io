---
layout: post
title:  "nodeJs学习（2）.md"
date:   2016-11-19 22:29:29 +0800
category: "javascript, nodeJs"
tags: [javascript, nodeJs]
---


### 内存的使用


#### 1. 作用域
在js中，能形成作用域的主要是函数调用、with、全局作用域。

如果变量是局部变量，由于全局作用域需要知道进程退出的时候才能释放，如果需要释放常驻内存的对象，可以通过delete或者将变量赋值为null和undefined，让旧的对象脱离引用关系。


> delete tips

delete 不能删除显式（例如用var, let ,const声明的变量），不过可以删除未经var等关键字声明的变量；

delete不能删除从原型继承而来的属性，不过你可以从原型上直接删除该属性。

当你删除一个数组元素时，数组的 length 属性并不会变小。例如，如果你删除了a[3], a[4]仍然是a[4], a[3]成为undefined. 即便你删除了最后一个元素也是如此 (delete a[a.length-1]).

当用 delete 操作符删除一个数组元素时，被删除的元素已经完全不属于该数组。下面的例子中， trees[3] 被使用delete彻底删除。

### 2. 闭包

在正常的执行中，js内存机制无法立即回收的内存有闭包和全局变量引用这两种情况，因此要小心这类变量的无限制的增加。


### 理解buffer

在node的应用场景中，需要处理网络协议，操作数据库，处理图片和上传的文件，处理大量的二进制数据，js自有的字符串远远不能满足这些需求，于是buffer对象应运而生。

buffer对象类似于数组，他的元素为16进制的两位数，即0到255的数值。

Buffer.from(value, ...)用于申请内存，并将内容写入刚刚申请的内存中，value值是多样的.例如：

- ArrayBuffer的实例: ArrayBuffer是ES2015里面引入的，用于在浏览器端直接操作二进制数据，这样Node就与ES2015关联起来，同时，新创建的Buffer与ArrayBuffer内存是共享的
- string: 该方法实现了将字符串转变为Buffer
- Buffer/TypeArray/Array: 会进行值的copy

```js
const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
console.log(buf)
```

buf.toString() 方法可以将buf对象转换成string类型。

```js
// 申请10个字节的内存
const buf2 = Buffer.alloc(10)
// 默认情况下，用0进行填充
buf2.toString() //'\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000'
```


### stream

在node中，流可以帮助我们将事情的重点分为几份，因为使用流可以帮助我们将实现接口的部分分割成一些连续的接口，这些接口都是可重用的。接着，你可以将一个流的输出口接到另一个流的输入口，然后使用使用一些库来对流实现高级别的控制。

.pipe()方法会自动帮助我们监听data和end事件。

在node中，一共有五种类型的流：readable,writable,transform,duplex以及"classic".

无论哪一种流，都会使用.pipe()方法来实现输入和输出。

.pipe()函数很简单，它仅仅是接受一个源头src并将数据输出到一个可写的流dst中：
.pipe(dst)将会返回dst因此你可以链式调用多个流:

```js
src.pipe(dst)
a.pipe(b).pipe(c).pipe(d)
```


Readable流可以产出数据，你可以将这些数据传送到一个writable，transform或者duplex流中，只需要调用pipe()方法

一个writable流指的是只能流进不能流出的流:

```js
src.pipe(writableStream)

```

如果你需要向一个writable流中写东西，只需要调用.write(data)即可。
process.stdout.write('beep boop\n');


Duplex流是一个可读也可写的流，就好像一个电话，可以接收也可以发送语音。一个rpc交换是一个duplex流的最好的例子。如果你看到过下面这样的代码：

a.pipe(b).pipe(a)
那么你需要处理的就是一个duplex流对象。

参考：
http://javascript.ruanyifeng.com/#advanced
https://github.com/sindresorhus/awesome-nodejs#streams


### fs

fs模块的所有方法都提供两种模式（asynchronous&synchronous）两种版本，即同步和异步。

const fs = require('fs');

fs.unlink('/tmp/hello', (err) => {
  if (err) throw err;
  console.log('successfully deleted /tmp/hello');
});

异步文件操作的异常和数据返回都被当做参数传入进回调函数中。
同步的异常会直接抛出，可以用try/catch方法进行处理或者直接让他们抛出。




### 未完待续（stream模块,Error模块，Events模块，fs模块，全局对象global模块， modules模块，path模块, process模块，Timers模块, util模块）
